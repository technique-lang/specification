; A grammar for the Technique procedures language. While intended to be as
; comprehensive as possible, there are some flexibilties that the reference
; parser admits that are not necessarily perfectly described here.
;
; This is written in the style of a Backus–Naur Form with a few augmentations.
; When specified, character classes are in the style of those accepted by
; regular expressions, such as [a-z]. Explicitly required characters such as
; spaces are marked with [ ]; a [.] represents a period and not any character.
; Otherwise special characters in regular expressions are not shown escaped.
;
; The convention adopted here is that names that represent actual types in the
; abstract syntax tree are in Proper Case whereas other definitions (often
; representing variants in enumerations in the implementation) are written in
; snake_case.

NEWLINE := "\n" | "\r\n"

; Arbitrary whitespace is allowed between most tokens.
SPACE := " " | "\t" | "\n"

; Specially defined as any characters but matching lazily, such that whatever
; token or pattern that follows is excluded.
ANY

; A document or file has an optional metadata header, followed by a technique.
Document := Metadata? Technique?

; If present, the document metadata are the magic bytes, followed by an
; optional statement of license and copyright, and an optional indication of
; what template is intended for rendering this technique.
Metadata := magic_line spdx_line? template_line?

magic_line := "%" "technique" "v1" NEWLINE

spdx_line := "!" license copyright? NEWLINE
license := [a-zA-Z0-9.,-_ ()[]]+
copyright := ";" ("©" | "(c)" | "(C)") ANY NEWLINE

template_line := "&" [a-zA-Z0-9.,-]+ NEWLINE

; A technique is either a series of steps, or a procedure (which of course
; can and usually does contain steps).
Technique := Scope+ | Procedure+

Procedure :=
    procedure_declaration
    procedure_title?
    procedure_description?
    Scope*

procedure_declaration := Identifier parameters? ":" signature? NEWLINE

Identifier := [a-z][a-z0-9_]*

parameters := "(" variable ("," variable)* ")"
variable := Identifier

signature := Genus "->" Genus

Genus := unit_genus | simple_genus | list_genus | tuple_genus | naked_genus
unit_genus := "()"
simple_genus := Forma
list_genus := "[" Forma "]"
tuple_genus := "(" Forma ("," Forma)+ ")"
naked_genus := Forma ("," Forma)+

Forma := [A-Z][a-zA-Z0-9_]*

procedure_title := "#" heading

heading := ANY NEWLINE

procedure_description := Paragraph+

Paragraph := Descriptive+ NEWLINE

Descriptive := ANY | code_inline | descriptive_binding

code_inline := "{" Expression "}"

descriptive_binding := Descriptive "~" identifiers

identifiers := Identifier | "(" Identifier ("," Identifier)* ")"

Expression :=
    variable |
    string_literal |
    multiline_literal |
    numeric_literal |
    Invocation |
    Application |
    foreach_keyword |
    repeat_keyword |
    expression_binding |
    tablet

Invocation := "<" invocation_target ">" ("(" arguments? ")")?

invocation_target := local_target | external_target
local_target := Identifier
external_target := "https://" [a-zA-Z0-9.,?&#%=:/-_]+

; A function call, usually to a built-in.
Application := function_name "(" arguments? ")"
function_name := Identifier

arguments := Expression ("," Expression)*

foreach_keyword := "foreach" identifiers "in" Expression

repeat_keyword := "repeat" Expression

expression_binding := Expression "~" identifiers

string_literal := "\"" string_content* "\""
string_content := plain_text | interpolation
plain_text := ANY
interpolation := "{" Expression "}"

; Multiline strings preserve internal structure and whitespace.
multiline_literal := "```" language? NEWLINE multiline_content "```"
multiline_content := ANY NEWLINE

language := [a-z]+

numeric_literal := integral | Quantity
integral := [0-9]+

Quantity := mantissa uncertainty? magnitude? symbol
mantissa := [0-9]+([.][0-9]+)?
uncertainty := ("±" | "+/-") [0-9]+([.][0-9]+)?
magnitude := "x" "10^" [0-9]+ | "×" "10" [⁰⁻⁹]
symbol := [a-zA-Z/°]+

Scope := step_block | code_block | Attribute | section_chunk | response_block

step_block := dependent_step+ | parallel_step+

dependent_step := [1-9][0-9]*[.][ ] Descriptive+ (dependent_substep+ | parallel_substep+)?

; Parallel substeps can not nest within parallel steps because there is no way
; for a parser to differentiate between the two levels (given the language is
; not indentation sensitive).
parallel_step := [-][ ] Descriptive+ (dependent_substep+ | code_block | Attribute )?

dependent_substep := [a-hj-km-uwyz][.][ ] Descriptive+ (dependent_subsubstep+ | parallel_subsubstep+ | Scope)?

parallel_substep := [-][ ] Descriptive+ (dependent_substep+ | dependent_subsubstep+ | Scope)?

dependent_subsubstep := [ivxl]+[.][ ] Descriptive+ | Scope?

parallel_subsubstep := [-][ ] Descriptive+ | Scope?

; A code block is effectively the same as a code inline; both escape from the
; textual language to being able to write expressions.
code_block := "{" NEWLINE Expression+ NEWLINE "}"

; An attribute is one or more rol=es or a places that the enclosed scope is
; to be performed by or applied to.
attributes := Attribute ("+" Attribute)*
Attribute := role_attribute | place_attribute
role_attribute := "@" Identifier
place_attribute := "^" Identifier

response_block := Response ("|" Response)*
Response := "'" response_value "'" response_condition?
response_value := ANY
response_condition :=  ANY

tablet := "[" Pair (NEWLINE Pair)* "]"

Pair := Label "=" Expression

Label := "\"" ANY "\""

; Last but not least, procedures can be grouped into sections, marked with
; capital roman numerals.
section_chunk := [IVX]+[.][ ] Descriptive* (Procedure+ | Scope+)?